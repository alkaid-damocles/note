[TOC]

### 1.Golang内存管理

- #### 内存分配：

  - 是指内存在程序执行过程中分配或者回收存储空间的分配内存的方法

- #### 内存管理包含的三个组件:

  - 应用程序
  - 内存分配器
  - 垃圾收集器（GC）

  #### 内存分配器：

  最重要指标： 速度， 空间利用率

- 常见内存分配方式

  - 线性分配器
    - 内存中维护一个指针， 分配内存时移动指针
    - 优点：简单高效
    - 缺点：之前分配的内存无法被回收，需要配合相应的回收算法， 如标记压缩，复制回收， 分代回收
  - 空闲链表分配器： 
    - golang内存分配基于此

- **TCMalloc**

  - Thread-cache malloc 线程缓存 malloc
  -  TCMalloc 是 Google 对 C 的 [malloc](https://so.csdn.net/so/search?q=malloc&spm=1001.2101.3001.7020)() 和 C++ 的 operator new 的自定义实现，用于在我们的 C 和 C++ 代码中进行内存分配。 TCMalloc 是一种快速、多线程的 malloc 实现。
  - TCMalloc的[官方介绍](https://gperftools.github.io/gperftools/tcmalloc.html)中将内存分配称为 object allocation（对象分配）


​	按照所分配对象内存的大小，TCMalloc 将内存分配分为三类：

- 小对象分配：[0kb - 255kb]中对象分配：[256kb - 1mb]
- 大对象分配：[1Mb - +∞]

然后介绍几个重要概念：

- page， TCMalloc 将整个虚拟内存划分成一个个page  1个page 8kb
- Span， 由连续的n个page组成的
- PegeHeap, 以span为单位向系统申请内存， 可能只有一个page， 也可能有多个

### 2.make和new的区别

共同点： 分配内存

不同点： make给引用类型分配内存并初始化， new给string int object 分配内存， 并返回指针

### 3.值类型和引用类型

值类型： 整形， 浮点， 字符串， 数组， 布尔， struct

引用类型： channel， map， slice， 指针

> - bool：1 字节（8 位）
> - int8：1 字节（8 位）
> - uint8（或 byte）：1 字节（8 位）
> - int16：2 字节（16 位）
> - uint16：2 字节（16 位）
> - int32（或 rune）：4 字节（32 位）
> - uint32：4 字节（32 位）
> - int64：8 字节（64 位）
> - uint64：8 字节（64 位）
> - float32：4 字节（32 位）
> - float64：8 字节（64 位）
> - complex64：8 字节（64 位）
> - complex128：16 字节（128 位）
> - string：1 字节/字符（默认使用 UTF-8 编码）
>
> 特殊类型:
>
> byte: 等于uint8, 常用来处理ascii字符
>
> rune: 等于int32, 常用来处理unicode字符或者utf8字符
>
> uintptr: 表示一个无符号整数, 用来存放指针, 一般是8字节64位, 但是在一些嵌入式系统中, 可能是2或者4字节

### 4.数组(array)和切片(slice)的区别

> **相同点：**
>
> 只能存储一组相同类型的数据结构
>
> 都是通过下标来访问，并且有容量长度，长度通过 len 获取，容量通过 cap 获取
>
> 数组的容量等于它的长度，因为数组在创建时就固定了长度，无法动态扩容。所以也可以认为数组没有容量这个概念
>
> **区别：**
>
> 数组是定长，访问和复制不能超过数组定义的长度，否则就会下标越界，切片长度和容量可以自动扩容
>
> 数组是值类型，切片是引用类型，每个切片都引用了一个底层数组，切片本身不能存储任何数据，都是这底层数组存储数据，所以修改切片的时候修改的是底层数组中的数据。切片一旦扩容，指向一个新的底层数组，内存地址也就随之改变
>
> 数组之间的copy是值传递, 也就是会在地址中开辟新的地址,并且复制相应的值
>
> 切片之间的copy是引用传递,也就是在copy时, 会引用到相同的底层数组   如下:
>
> ```golang
> a := [3]int{1, 1, 1}
> b := a
> a[1] = 2
> c := []int{1, 1, 1}
> d := c
> c[1] = 2
> 
> fmt.Println(a, b, c, d)  //[1 2 1] [1 1 1] [1 2 1] [1 2 1]
> ```
>
> **初始化:**
>
> ```golang
> // 数组
> var array [2]int
> var array [...]int
> array := [2]int{}
> array := [...]int{}
> array := [2]int{1,2}
> //切片
> var slice []int
> slice := []int{}
> slice := make([]int, 2) // 2是长度
> slice := make([]int, 2, 5)// 2是长度, 5是容量, 主要用于判断是否扩容, 此时底层是一个长度为5的数组
> ```

### 5.range关键字

> `range`关键字是Go语言中的一个迭代器，用于遍历数组、切片、字符串、映射(map)和通道(channel)等数据结构中的元素。

`range`的用法有两种：

> 遍历数组、切片、字符串等具有长度的数据类型时，`range`返回当前元素的索引和值。
>
> 遍历映射(map)和通道(channel)时，`range`返回当前元素的键和值。

1. 遍历数组、切片、字符串

   > 在遍历数组、切片、字符串时，`range`返回两个值，第一个值是元素的下标，第二个值是元素的值。可以使用`_`忽略其中一个值。

   ```golang
   cssCopy code
   arr := [3]int{1, 2, 3}
   for i, v := range arr {
       fmt.Printf("arr[%d]=%d\n", i, v)
   }
   // 输出结果为：
   cssCopy code
   arr[0]=1
   arr[1]=2
   arr[2]=3
   ```

2. 遍历映射(map)

   > 在遍历映射(map)时，`range`返回两个值，第一个值是键(key)，第二个值是键对应的值(value)。

   ```go
   goCopy code
   m := map[string]int{"a": 1, "b": 2}
   for k, v := range m {
       fmt.Printf("%s:%d\n", k, v)
   }
   
   //输出结果为：
   makefileCopy code
   a:1
   b:2
   ```

3. 遍历通道(channel)

   > 当我们使用`range`遍历通道(channel)时，其实是遍历通道中的元素，通道中的元素只有值没有键。具体来说，`range`语句在每次迭代时，都会从通道(channel)中取出一个元素，并将其赋值给迭代变量

   ```go
   ch := make(chan int)
   
   go func() {
       ch <- 1
       ch <- 2
       ch <- 3
       close(ch)
   }()
   
   for v := range ch {
       fmt.Println(v)
   }
   // 1,2,3	
   ```

需要注意的是，当遍历切片或数组时，`range`返回的第一个值是元素的下标，而不是元素本身。如果不需要使用元素的下标，可以使用`_`忽略该值。

此外，当遍历通道(channel)时，如果通道没有关闭，`range`会一直阻塞等待新的数据，如果通道关闭，则会退出循环。遍历通道时，`range`返回的是通道中的值，而不是值的下标。

综上所述，`range`关键字是Go语言中用于遍历数据结构的迭代器，可以方便地遍历数组、切片、字符串、映射和通道等数据结构中的元素。

### 6.通道(channel)

通道（channel）是用来传递数据的一个数据结构。

通道可用于两个 goroutine 之间通过传递一个指定类型的值来同步运行和通讯。操作符 `<-` 用于指定通道的方向，发送或接收。如果未指定方向，则为双向通道。

通道可以用 make 函数来创建，语法如下：

```go
make(chan 元素类型, 缓冲大小)
```

其中，元素类型是通道中要传输的数据的类型，缓冲大小是通道中可以缓存的元素个数，可以是一个正整数或者省略。如果缓冲大小为 0 或者省略，那么通道就是无缓冲的，只有在发送者和接收者同时准备好时，数据才能被传输。如果缓冲大小大于 0，那么通道就是有缓冲的，发送者可以在缓冲未满时发送数据，而接收者可以在缓冲不为空时接收数据。

通道的发送和接收操作都是阻塞的，也就是说，当通道满时，发送者会一直阻塞直到有空间可以发送，当通道为空时，接收者会一直阻塞直到有数据可以接收。如果通道被关闭，那么接收者会立即接收到一个零值，而且无法再向通道发送数据。

通道可以用于实现多个 goroutine 之间的协作和同步。例如，可以用通道来实现 goroutine 之间的任务分配和结果汇总，或者用通道来控制并发访问共享资源的顺序和数量。

通道是 Go 语言中非常重要的并发原语，也是开发并发程序的基础。对于想要学习并发编程的开发者来说，深入理解通道的使用和原理是非常有必要的。

#### 1.是否线程安全

线程安全, Hchan结构体中使用mutex锁实现互斥, 在缓存buf的进行入队和出队操作时, 都需要先获取互斥锁

#### 2.主要用途

> Go语言的通道（channel）主要用于在 goroutine 之间传递数据和同步操作。
>
> 通道提供了一个安全且高效的机制，使得在不同的 goroutine 之间传递数据变得容易和可靠。通道是一个可以被多个 goroutine 同时读写的对象，它具有以下特点：
>
> 1. 阻塞式操作：当一个 goroutine 向通道发送数据时，如果此时没有其他 goroutine 正在接收数据，那么发送操作就会被阻塞，直到有其他 goroutine 开始接收数据为止。同理，当一个 goroutine 从通道接收数据时，如果此时没有其他 goroutine 正在发送数据，那么接收操作也会被阻塞，直到有其他 goroutine 开始发送数据为止。这种阻塞式操作保证了通道的线程安全性。
> 2. 同步操作：通道可以用来同步多个 goroutine 的执行。比如，当一个 goroutine 需要等待另一个 goroutine 完成某个操作之后才能继续执行时，可以使用通道来进行同步。通道提供了一个机制，使得一个 goroutine 可以等待另一个 goroutine 完成某个操作，并从通道中接收信号来继续执行。
> 3. 数据传递：通道可以被用来在多个 goroutine 之间传递数据。比如，一个 goroutine 可以向通道中发送一个数据项，另一个 goroutine 可以从通道中接收这个数据项，并进行相应的处理。通道提供了一个安全、高效的机制，使得在不同的 goroutine 之间传递数据变得容易和可靠。
>
> 在Go语言的并发编程中，通道是一个非常重要的概念，它为我们提供了一种安全、高效、易用的并发编程模型。

#### 3.底层结构

```go
type hchan struct {
	qcount   uint           // channel中环形队列数据总数，len()返回该值
	dataqsiz uint           // 环形队列的长度，make时指定，cap()返回该值
	buf      unsafe.Pointer // 指向环形队列的指针，缓存区基于环形队列实现
	elemsize uint16			// 元素的大小
	closed   uint32			// channel关闭标志
	elemtype *_type 		// 元素类型
	sendx    uint   		// 向channel发送数据时，写入的位置索引
	recvx    uint   		// 从channel读数据是，读取的位置索引
	recvq    waitq  		// buf空时，读取的goroutine等待队列
	sendq    waitq  		// buf满时，写入的goroutine等待队列

	// lock protects all fields in hchan, as well as several
	// fields in sudogs blocked on this channel.
	//
	// Do not change another G's status while holding this lock
	// (in particular, do not ready a G), as this can deadlock
	// with stack shrinking.
	lock mutex				// 并发控制锁，同一时刻，只允许一个
}
```

> 通道实现原理
>
> 在Go语言中，通道是通过内部的同步机制来实现线程安全的。具体来说，每个通道都有一个内部的锁（mutex），当一个 goroutine 访问通道时，会自动获取这个锁，其他 goroutine 在此时会被阻塞，等待锁的释放。
>
> 当一个 goroutine 发送数据到通道时，如果通道已满，那么这个 goroutine 会被阻塞，等待其他 goroutine 从通道中取出数据，释放出空间。当一个 goroutine 从通道中取出数据时，如果通道为空，那么这个 goroutine 会被阻塞，等待其他 goroutine 向通道中发送数据。
>
> 除此之外，Go语言的编译器和运行时系统还会根据通道的具体使用情况，优化通道的实现。例如，当通道被作为函数参数传递时，编译器可能会使用更为高效的内存布局方式，以减少内存分配和复制的开销。
>
> 总之，Go语言的通道是一种非常方便、高效、可靠的线程安全机制，它的底层结构和实现原理都是由编译器和运行时系统共同实现的。

#### 4.常见问题(如再次关闭已关闭的通道)

channel有2种类型: 1.有缓存通道  2.无缓存通道

channel有3中模式: 1.读模式通道  2.写模式通道  3.读写模式通道

| 执行操作\目前状态 | 未初始化         | 关闭                             | 正常             |
| ----------------- | ---------------- | -------------------------------- | ---------------- |
| 关闭              | panic            | panic                            | 正常关闭         |
| 发送数据          | 永远阻塞导致死锁 | panic                            | 阻塞或者成功发送 |
| 接收数据          | 永远阻塞导致死锁 | 缓冲区空为零值, 负责继续接收数据 | 阻塞或者成功读取 |

#### 5.使用场景 

消息传递、消息过滤，信号广播，事件订阅与广播，请求、响应转发，任务分发，结果汇总，并发控制，限流，同步与异步

#### 6.发送数据和接收数据流程

**阻塞式和非阻塞式主要在于对 通道是否初始化的判断, 如果未初始化, 则非阻塞式直接返回false, 阻塞式会直接阻塞当前goroutine**

**非阻塞式发送和接收, 一般是在使用select时, 系统编译为非阻塞式发送或者接收**

**发送数据:**  分为阻塞式发送和非阻塞式发送, 但是调用的都是chansend函数

1.加锁

2.首先检查接收队列是否为空, 如果不为空, 直接发送给第一个等待接收的goroutine, 然后唤醒它

3.如果接收队列为空, 则检查缓冲区, 如果缓冲区未满, 则加入缓冲区

4.缓冲区已满, 则加入发送队列, 并挂起goroutine,等待被唤醒, 如果是非阻塞式发送, 则直接返回false

5.释放锁

![img](/Users/alkaid/Desktop/note/assets/e9cf2f21ff728628c9479c15073e4f0a.png)

**接收数据:** 也分为阻塞式接收, 和非阻塞式接收, 都调用chanrecv函数

1.加锁

2.判断发送队列, 如果不为空, 分为两种情况:

​	1.无缓存, 直接将发送队列首位goroutine的值拷贝给接收变量,唤醒该goroutine

​	2.有缓存, 将缓存的首位值拷贝给接收变量, 然后将发送队列首位值加入buf末尾, 唤醒该goroutine

3.如果发送队列为空

​	1.无缓存, 或者缓存为空, 走阻塞流程, 如果是非阻塞接收, 则直接返回false, 当前队列加入结构队列, 挂起等待唤醒

​	2.缓存不为空, 则复制缓存中第一个值, 

4.释放锁

![img](/Users/alkaid/Desktop/note/assets/f8030a2794bc55a0f81e99f9a96e300c.png)

#### 7.关闭流程

1.判断是否初始化, 未初始化,直接panic

2.加锁

3.检查是否已关闭, 已关闭则释放锁并panic

4.将channel的closed的值设置为1，

5.获取所有的recvq的接收者，sendq的写入者到glist

6.释放锁

7.唤醒所有glist中的goroutine

![img](/Users/alkaid/Desktop/note/assets/de8f83801d6df12f6b5a6c7037f5e528.png)

### 7.select关键字

在Go语言中，select关键字是一种用于多路复用通道的机制。它可以让我们同时等待多个通道的操作，并在其中任何一个通道就绪时立即执行相应的操作。

select语句的语法与switch语句类似，但它用于选择通道操作而非值操作。在select语句中，我们可以使用case语句来监听通道的操作，包括读、写和关闭操作。当其中任何一个通道就绪时，select语句就会立即执行相应的操作。

下面是一个简单的例子，演示了select的用法：

```go
package main

import (
    "fmt"
    "time"
)

func main() {
    c1 := make(chan string)
    c2 := make(chan string)

    go func() {
        time.Sleep(time.Second)
        c1 <- "one"
    }()
    go func() {
        time.Sleep(time.Second * 2)
        c2 <- "two"
    }()

    for i := 0; i < 2; i++ {
        select {
        case msg1 := <-c1:
            fmt.Println("received", msg1)
        case msg2 := <-c2:
            fmt.Println("received", msg2)
        }
    }
}
```

在这个程序中，我们创建了两个通道c1和c2，并在两个不同的goroutine中分别向它们发送了数据。在主goroutine中，我们使用select语句监听这两个通道的操作，并在其中任何一个通道就绪时立即执行相应的操作。

当第一个goroutine向c1通道发送了数据后，程序会执行第一个case语句，并输出"received one"。然后程序会继续执行for循环，等待第二个通道的数据。当第二个goroutine向c2通道发送了数据后，程序会执行第二个case语句，并输出"received two"。这样程序就完成了对这两个通道的监听，并顺利退出了。

> **注意，**每次select语句只会执行一个case语句，即使多个通道都就绪了。如果多个case同时就绪，Go语言会在其中随机选择一个执行。如果所有通道都没有就绪，那么select语句就会阻塞，直到其中任何一个通道就绪为止。
>
> 在使用select语句时，我们还可以为每个case语句设置超时时间。如果在指定时间内没有任何一个通道就绪，那么程序就会执行default语句，或者继续等待通道就绪。这种机制可以有效避免因为某个通道长时间未就绪而导致程序无限阻塞的情况。

```go
package main

import (
	"fmt"
	"time"
)

func main() {
	c := make(chan string, 1)
	go func() {
		time.Sleep(2 * time.Second)
		c <- "result"
	}()

	select {
	case res := <-c:
		fmt.Println(res)
	case <-time.After(1 * time.Second):
		fmt.Println("timeout 1")
	default:
		fmt.Println("default case")
	}
}

```

> 在上面的例子中, default语句优先级高于,超市控制语句 但是不具有超时控制功能, 如果每个case都没有就绪, 就会执行default语句

### 8.defer关键字

`defer`是Go语言中的一个关键字，用于延迟函数的执行。当一个函数中存在多个`defer`语句时，它们的执行顺序是倒序的，即后定义的`defer`语句先执行，先定义的`defer`语句后执行。`defer`语句通常用于在函数执行完毕之后释放资源、关闭文件等操作。

下面是一个使用`defer`语句的例子：

```go
func test() {
    defer fmt.Println("world")
    fmt.Println("hello")
}

// 输出:
hello
world
```

`defer`语句不仅可以延迟函数的执行，还可以在函数执行完毕之后获取函数的返回值并进行修改。例如：

```go
goCopy code
func test() (result int) {
    defer func() {
        result += 10
    }()
    return 100
}
```

> **defer的实现是通过一个栈来实现的，每当遇到一个defer语句时，会将要执行的函数推入栈中。当函数执行结束后，会依次从栈中弹出函数并执行，直到栈中的所有函数都被执行完毕。**
>
> **defer无法修改return 语句中的值**

### 9.反射

反射是指程序在运行时可以获取自身信息并操作自身的能力，而不需要预先知道程序的结构。在 Golang 中，使用 reflect 包可以实现反射。

反射的主要作用是在运行时动态地获取一个值的类型信息和值的各种属性（比如字段、方法等），并能够通过反射操作这些属性。反射常用于实现通用的代码库，比如序列化/反序列化、动态调用函数等。

在 Golang 中，使用 reflect 包进行反射主要分为以下几个步骤：

1. 获取变量的 Type 对象：使用 reflect.TypeOf 函数获取变量的 Type 对象，Type 对象包含了变量的类型信息。
2. 获取变量的 Value 对象：使用 reflect.ValueOf 函数获取变量的 Value 对象，Value 对象包含了变量的值。
3. 获取变量的类型信息：通过 Type 对象可以获取变量的类型信息，包括名称、大小、字段、方法等。
4. 获取变量的值信息：通过 Value 对象可以获取变量的值信息，包括整数、浮点数、字符串、结构体、函数等。
5. 修改变量的值信息：使用 Value 对象可以直接修改变量的值信息。

在使用反射时需要注意一些问题：

1. 反射会带来性能损失，因为它需要在运行时动态获取类型信息，而不是编译时静态绑定。
2. 反射只能操作可导出的字段和方法。
3. 对于基本类型和不可寻址的值，无法直接修改其值，需要使用指针来间接修改。
4. 反射并不是万能的，它只能用于处理编译时类型已知的情况。对于动态类型的数据，反射无能为力。

总的来说，反射是 Golang 中一个非常强大的特性，可以实现很多灵活的代码设计。但是反射也有其局限性，需要合理使用，避免对性能造成过大的影响。

### 10.slice切片扩容机制

> 1.5 版本:  new_cap =  2* old_cap
>
> 1.5 -1.17:  new_cap =  1.25 * old_cap
>
> 1.17版本之后:
>
> 容量小于1k  new_cap =  2* old_cap
>
> 容量大于1k  new_cap =  1.25 * old_cap
>
> 1.18版本之后:
>
> new_cap =  1.25 * old_cap + 0.75 * threshold   threshold为 256, 512, 1024, 2048, 4096 按照 old_cap 大小取值
>
> 最终扩容结果:
>
> ![在这里插入图片描述](/Users/alkaid/Desktop/note/assets/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAR29Hb-WcqOWKquWKmw==,size_20,color_FFFFFF,t_70,g_se,x_16.png)

### 11.单引号，双引号，反引号的区别？

单引号，表示byte类型或rune类型，对应 uint8和int32类型，默认是 rune 类型。byte用来强调数据是raw data，而不是数字；而rune用来表示Unicode的code point。

双引号，才是字符串，实际上是字符数组。可以用索引号访问某字节，也可以用len()函数来获取字符串所占的字节长度。

反引号，表示字符串字面量，但不支持任何转义序列。字面量 raw literal string 的意思是，你定义时写的啥样，它就啥样，你有换行，它就换行。你写转义字符，它也就展示转义字符。

### 12.map

无序

> 无序的, map 因扩张⽽重新哈希时，各键值项存储位置都可能会发生改变，顺序自然也没法保证了，所以官方避免大家依赖顺序，直接打乱处理。就是 for range map 在开始处理循环逻辑的时候，就做了随机播种

**map 中删除一个 key，它的内存会释放么**

> 如果删除的元素是值类型，如int，float，bool，string以及数组和struct，map的内存不会自动释放
>
> 如果删除的元素是引用类型，如指针，slice，map，chan等，map的内存会自动释放，但释放的内存是子元素应用类型的内存占用
>
> 将map设置为nil后，内存被回收。
>
> 如果删除的元素是值类型，如int，float，bool，string以及数组和struct，map的内存不会自动释放
>
> 如果删除的元素是引用类型，如指针，slice，map，chan等，map的内存会自动释放，但释放的内存是子元素应用类型的内存占用
>
> 将map设置为nil后，内存被回收。

**并发**

> map本身是线程不安全, 如果需要并发, 需要内置的**sync.Map** , 或读写锁手动控制

**初始化**

> 未初始化的map == nil, 可以读,可以取长度,  不能写, 会报panic

**map key 类型**

> ![image-20230419174926300](/Users/alkaid/Desktop/note/assets/image-20230419174926300.png)
>
> 在 Go 语言中，`slice` 是一种动态数组，可以根据需要动态增加或缩小长度，也可以在中间插入或删除元素。因此，`slice` 的长度和容量可能不同，而且底层数组的地址也可能会发生改变。
>
> 由于 `map` 的键必须是可比较的类型，而 `slice` 的长度、容量和底层数组的地址可能会发生改变，因此 `slice` 不是可比较的类型，也就不能作为 `map` 的键。
>
> `map` 是一种引用类型，它本身是一个指向底层数据结构的指针。由于 `map` 是一个指针类型，因此它们在使用时必须初始化，如果未初始化，它们将默认为 `nil`。
>
> 在 Go 语言中，可比较的类型是指可以使用 `==` 运算符进行比较的类型，例如 `int`、`string`、`bool` 等。对于可比较的类型，可以将它们作为 `map` 的键或结构体的字段。
>
> 但是，由于 `map` 本身是一个指针类型，而且底层数据结构的内部布局是不公开的，因此在编译时无法确定两个 `map` 是否相等。因此，`map` 不是可比较的类型，也就不能将它们作为 `map` 的键或结构体的字段。

**数据结构和扩容机制**

> Go map的底层实现是一个**哈希表**（**数组 + 链表**），使用**拉链法消除哈希冲突**，因此实现map的过程实际上就是实现[哈希表](https://so.csdn.net/so/search?q=哈希表&spm=1001.2101.3001.7020)的过程。
>
> 先来看下go map底层的具体结构：
>
> ```go
> type hmap struct {
> 	count      int            // 元素个数，调用len(map)返回这个值
> 	B          uint8          // bucket数量是2^B, 最多可以放 loadFactor * 2^B 个元素，再多就要扩容了
> 	hash0      uint32         // hash seed
> 	buckets    unsafe.Pointer // 指向bucket数组的指针（存储key val）；大小：2^B 
> 	oldbuckets unsafe.Pointer // 扩容时，buckets 长度是 oldbuckets 的两倍
> 	// ...
> }
> type bmap struct {
> 	topbits  [8]uint8     // 高位哈希值数组
> 	keys     [8]keytype   // 存储key的数组
> 	values   [8]valuetype // 存储val的数组
> 	overflow uintptr      // 指向当前bucket的溢出桶
> 	// 为缓解当存在多个key计算后的哈希值低8位相同的个数大于一个bucket所能存放的数目8个时，且这个map还没达到扩容条件时，做的一种存储设计。
> }
> ```

### 10.GPM模型

> Go 的 GPM（Goroutine, Processor, and Machine）模型是 Go 语言运行时系统的核心模型，用于管理协程的调度和执行。
>
> GPM 模型包括以下三个重要的组件：
>
> 1. Goroutine：Goroutine 是 Go 语言中轻量级的并发执行单位，与操作系统线程不同，可以在一个线程中运行多个 goroutine。Goroutine 由 Go 运行时系统进行管理，包括创建、调度、销毁等操作。
> 2. Processor：Processor 是一个逻辑处理器，用于执行 goroutine。Go 语言运行时系统会根据需要创建一定数量的 Processor，这些 Processor 可以在多个操作系统线程上并发执行 goroutine。
> 3. Machine：Machine 是指运行 Go 语言程序的机器，它可以是一台物理机器或虚拟机。在 Machine 上运行的 Go 程序可以创建多个线程和 goroutine，由 Go 运行时系统进行调度和管理。
>
> GPM 模型的核心思想是，将多个 goroutine 分配给多个 Processor 执行，同时通过队列和信号量等机制，实现了 goroutine 的调度和同步。具体来说，当一个 goroutine 需要执行时，它会被放入一个全局队列中，而 Processor 会从队列中取出 goroutine 并执行它，如果 goroutine 遇到阻塞操作，Processor 会将其挂起并继续执行其他 goroutine，直到阻塞操作完成后再继续执行该 goroutine。
>
> GPM 模型的设计使得 Go 语言可以在多核机器上实现高并发和高吞吐量的程序，同时保证了调度和同步的高效性和可靠性。
>
> G 理论上个数是无限的, 受内存限制,
>
> P的设置的 GoMAXPROCS 决定，但是不论 GoMAXPROCS 设置为多大，P 的数量最大为 256
>
> M由Go runtime 决定, 默认最大值10000

#### 1.进程 线程 协程

进程: 是应用程序的启动实例，每个进程都有独立的内存空间，不同的进程通过操作系统提供的进程间的通信方式来通信。

线程: 从属于进程，每个进程至少包含一个线程，线程是 CPU 调度的基本单位，多个线程之间可以共享该进程的地址空间和资源, 通过该进程共享内存等线程间的通信方式来通信。

协程: 为用户态的轻量级线程，与线程相比，协程不受操作系统的调度，协程的调度器由用户应用程序提供，协程调度器按照调度策略把协程调度到线程中运行

#### 2.为什么使用协程

> 1. 轻量级：协程是由 Go 运行时（Goroutine scheduler）调度的，而不是由操作系统调度，因此创建和销毁协程的开销非常小，可以在同一个线程中运行多个协程，提高了并发性能。
> 2. 并发：Go 的协程可以实现高并发的任务处理，每个协程相对于线程来说占用的资源更少，可以同时运行大量协程，提高程序的并发性能。
> 3. 简单易用：在 Go 中，协程的使用非常简单，只需要使用关键字 `go` 就可以启动一个协程，而不需要像线程一样需要手动创建、销毁、同步和通信。
> 4. 异步编程：Go 中的协程可以使用 channel 进行通信和同步，实现了高效的异步编程，而不需要使用回调函数或者复杂的线程同步和通信机制。
>
> 综上所述，Go 的协程可以提供高并发、高性能的异步编程模型，并且使用起来非常简单方便，因此被广泛应用于网络编程、并发编程等领域。

轻量主要体现在上下文切换代价小和内存占用小

**上下文切换代价小：** Goroutine 上下文切换只涉及到三个寄存器（PC / SP / DX）的值修改；而对比线程的上下文切换则需要涉及模式切换（从用户态切换到内核态）、以及 16 个寄存器、PC、SP…等寄存器的刷新；

**内存占用少：**线程栈空间通常是 2M，Goroutine 栈空间最小 2K；

Golang 程序中可以轻松支持**10w 级别**的 Goroutine 运行，而线程数量达到 1k 时，内存占用就已经达到 2G。这在高并发开发中差距明显

#### 3.抢占式还是协作式

抢占式调度: 

指操作系统或运行时系统可以强制中断当前正在执行的任务，并将 CPU 分配给其他任务。这种调度方式是在 CPU 执行一个任务的时间片到期或者优先级更高的任务到来时，会强制中断当前任务，并将 CPU 分配给优先级更高的任务。这个过程称为抢占，因为操作系统或运行时系统可以“抢占”CPU控制权，强制执行更高优先级的任务。

协作式调度:

指任务只有在主动放弃 CPU 的控制权时，才会将 CPU 分配给其他任务。这种调度方式是在当前任务主动发起一个阻塞操作（如等待 I/O 完成、等待其他任务完成等）或者主动调用某个特定的函数（如 sleep、yield 等）时，才会将 CPU 分配给其他任务。

> go1.13版本之前是协作式调度, 1.14版本之后是抢占式调度, 抢占流程大致如下：
>
> 1. M启动前，首先注册绑定SIGURG信号及其信号处理函数handler
> 2. sysmon间隔性的检测运行超时的P，然后发信号给P对应的M
> 3. M收到信号后休眠当前goroutine并重新进行调度
>
> 具体可看[Go语言协程模型介绍 - 知乎 (zhihu.com)](https://zhuanlan.zhihu.com/p/542783055)

#### 4.协程之间通信

##### 共享内存: 可以使用全局变量来在协程之间共享数据，但需要保证并发安全性，避免数据竞争等问题。

##### CSP（communicating sequential processes）并发模型： 也就是go语言 channel的方式来通信。

共享内存的互斥问题, 可以使用锁或者原子操作

### 11.锁

#### 1.共享变量的安全访问

> 1. 互斥锁：可以使用互斥锁来保护共享变量，避免多个协程同时访问共享变量导致的数据竞争等问题。在访问共享变量之前，协程可以加锁，访问完毕后再解锁。这样可以保证在任何时刻只有一个协程在访问共享变量，避免数据竞争等问题。但是，使用互斥锁会影响程序的性能，因为加锁和解锁需要消耗时间。
> 2. 原子操作：可以使用原子操作来对共享变量进行原子性的读取、修改和写入，避免数据竞争等问题。在 Go 语言中，原子操作可以通过 atomic 包中提供的原子函数来实现。使用原子操作可以避免加锁和解锁的开销，提高程序的性能。但是，原子操作只能对一些简单类型的变量进行操作，对于复杂类型的变量可能不太方便。
> 3. 通道：可以使用通道来传递数据，避免多个协程同时访问共享变量导致的数据竞争等问题。在 Go 语言中，通道是一种线程安全的队列，协程可以向通道发送数据或者从通道接收数据，当有数据可用时，接收操作和发送操作都可以被立即执行，否则它们都会被阻塞，直到有数据可用或者有协程来接收数据。通过通道来传递数据可以避免多个协程同时访问共享变量导致的数据竞争等问题，保证程序的正确性和并发安全性。
> 4. 个数为1的信号量实现互斥
>
> 总之，在使用全局变量时，需要考虑并发安全性和程序性能等问题，根据具体的场景选择适合的方式来保证全局变量的安全性。

#### 2.原子操作和锁的区别

互斥锁是一种数据结构，用来让一个线程执行程序的关键部分，完成互斥的多个操作。

原子操作是针对某个值的单个互斥操作。

> 原子操作和锁都是用于并发控制的机制，它们的主要区别在于操作粒度和效率。
>
> 原子操作是指在执行期间不会被中断的操作，即该操作被看作一个单一不可分割的操作，要么全部执行成功，要么全部失败。在 Go 语言中，可以使用原子操作来对共享变量进行操作，以确保并发访问的安全性。原子操作一般比锁的效率更高，因为它不需要进入内核态，不会涉及到系统调用等开销。
>
> 锁是一种较为常见的并发控制机制，它可以实现对共享资源的互斥访问，从而保证并发访问的安全性。在 Go 语言中，可以使用互斥锁（Mutex）和读写锁（RWMutex）等机制来实现并发控制。锁的操作粒度更细，可以针对单个共享变量或共享资源进行加锁和解锁，因此锁相对来说更加灵活。但是锁的效率相对较低，因为锁的操作需要进入内核态，可能涉及到系统调用等开销。
>
> 因此，当需要对共享变量进行单一操作时，可以使用原子操作来实现并发控制，以提高程序的效率；当需要对多个共享变量或共享资源进行操作时，可以使用锁来实现并发控制，以确保程序的正确性。同时，在实际使用时，还需要根据具体情况选择适当的机制，以保证程序的性能和正确性。

#### 3.读写锁的互斥锁

> 读写锁（RWMutex）和互斥锁（Mutex）是 Go 语言中两种常见的并发控制机制，它们的区别主要体现在以下几个方面：
>
> 1. 锁的类型：互斥锁只有一种类型，即 Mutex，它用于实现互斥访问；而读写锁则有两种类型，分别是读锁和写锁，用于实现共享资源的读写操作。
> 2. 锁的粒度：互斥锁的粒度更细，只能保护单个共享变量或共享资源；而读写锁的粒度更大，可以同时保护多个读操作或一个写操作。
> 3. 锁的竞争：互斥锁适合对共享变量或共享资源的写操作进行保护，因为写操作是互斥的，只有一个 goroutine 能够进行写操作，而其他 goroutine 需要等待。读写锁则适合对共享变量或共享资源的读操作进行保护，因为读操作是并发的，多个 goroutine 可以同时进行读操作。
> 4. 性能：读写锁相对于互斥锁，能够提供更好的并发性能。因为读写锁允许多个 goroutine 同时读取共享变量或共享资源，而互斥锁只能允许一个 goroutine 进行读写操作。
>
> 总的来说，如果并发程序中读操作比写操作更频繁，那么可以使用读写锁来提高程序的并发性能；如果读写操作的频率相差不大或者写操作比较频繁，那么使用互斥锁可能更为适合。

#### 4.悲观锁和乐观锁

**悲观锁**

悲观锁：当要对数据库中的一条数据进行修改的时候，为了避免同时被其他人修改，最好的办法就是直接对该数据进行加锁以防止并发。这种借助数据库锁机制，在修改数据之前先锁定，再修改的方式被称之为悲观并发控制【Pessimistic Concurrency Control，缩写“PCC”，又名“悲观锁”】。

**乐观锁**

乐观锁是相对悲观锁而言的，乐观锁假设数据一般情况不会造成冲突，所以在数据进行提交更新的时候，才会正式对数据的冲突与否进行检测，如果冲突，则返回给用户异常信息，让用户决定如何去做。乐观锁适用于读多写少的场景，这样可以提高程序的吞吐量

#### 5.Mutex 有几种模式？

##### 正常模式

1. 当前的mutex只有一个goruntine来获取，那么没有竞争，直接返回。
2. 新的goruntine进来，如果当前mutex已经被获取了，则该goruntine进入一个先入先出的waiter队列，在mutex被释放后，waiter按照先进先出的方式获取锁。该goruntine会处于自旋状态(不挂起，继续占有cpu)。
3. 新的goruntine进来，mutex处于空闲状态，将参与竞争。新来的 goroutine 有先天的优势，它们正在 CPU 中运行，可能它们的数量还不少，所以，在高并发情况下，被唤醒的 waiter 可能比较悲剧地获取不到锁，这时，它会被插入到队列的前面。如果 waiter 获取不到锁的时间超过阈值 1 毫秒，那么，这个 Mutex 就进入到了饥饿模式。

##### 饥饿模式

在饥饿模式下，Mutex 的拥有者将直接把锁交给队列最前面的 waiter。新来的 goroutine 不会尝试获取锁，即使看起来锁没有被持有，它也不会去抢，也不会 spin（自旋），它会乖乖地加入到等待队列的尾部。 如果拥有 Mutex 的 waiter 发现下面两种情况的其中之一，它就会把这个 Mutex 转换成正常模式:

1. 此 waiter 已经是队列中的最后一个 waiter 了，没有其它的等待锁的 goroutine 了；
2. 此 waiter 的等待时间小于 1 毫秒。

#### 6.自旋

自旋是一种并发控制机制，在该机制中，当线程需要获取锁时，如果发现锁已经被其他线程持有，它会以循环的方式不断尝试获取锁，而不是进入休眠状态等待其他线程释放锁。这种方式称为自旋。

自旋的基本思想是在短时间内循环等待锁的释放，避免线程进入阻塞状态，从而减少线程上下文切换的开销。自旋通常适用于锁被持有的时间很短的情况下，因为如果锁被持有的时间较长，那么自旋的次数就会增多，从而浪费CPU资源，甚至可能导致线程饥饿现象。

在实现自旋时，可以设置自旋次数或自旋的时间阈值，如果尝试获取锁的时间超过了这个阈值，线程就会放弃自旋，转而进入休眠等待。这样可以避免自旋时间过长，浪费CPU资源，同时也可以避免自旋次数过多，导致线程饥饿现象。

自旋常用于多核CPU上的并发控制，因为多核CPU上线程切换的开销比单核CPU要大得多，自旋可以有效地减少线程切换的开销，提高并发处理能力。

#### 7.goroutine的自旋占用资源如何解决, 或者如何结束自旋

**自旋的条件如下：**

> 还没自旋超过 4 次,
>
> 多核处理器，
>
> GOMAXPROCS > 1，
>
> p 上本地 goroutine 队列为空。

mutex 会让当前的 goroutine 去空转 CPU，在空转完后再次调用 CAS 方法去尝试性的占有锁资源，直到不满足自旋条件，则最终会加入到等待队列里。
