[TOC]

### 1.redis是什么

由c语言开发的高性能的非关系型数据库。

> Redis是一个开源的内存数据存储系统，它也可以用作数据库、缓存和消息代理。Redis的全称是Remote Dictionary Server（远程字典服务器），它是一个基于键值对的高性能存储系统。
>
> Redis以其高性能和灵活的数据结构而闻名。它完全存储在内存中，因此具有非常快的读写速度。此外，Redis还支持持久化，可以将数据保存到磁盘上，以便在系统重启后仍然保留数据。
>
> Redis支持多种数据结构，包括字符串、哈希表、列表、集合和有序集合。这些数据结构不仅支持基本的增删改查操作，还提供了各种高级功能，例如原子操作、事务、发布订阅模式和按范围查询等。
>
> Redis还提供了多个客户端库，使开发人员可以使用多种编程语言与Redis进行交互。这使得Redis成为许多应用程序中的首选解决方案，尤其是需要快速读写和高并发性能的场景，如缓存、会话存储和实时分析等。
>
> 总而言之，Redis是一个功能强大的内存数据存储系统，具有高性能、灵活的数据结构和丰富的功能，适用于各种应用场景。

**优势:**

> 1. 高性能：Redis主要存储在内存中，这使得它具有非常快的读写速度。相比传统的磁盘存储系统，Redis可以提供更低的延迟和更高的吞吐量。此外，Redis还使用了一些优化技术，如异步操作、非阻塞IO和基于事件驱动的架构，进一步提升了性能。
> 2. 多样的数据结构：Redis支持多种数据结构，如字符串、哈希表、列表、集合和有序集合，这使得开发人员可以选择最适合其应用需求的数据结构。不同的数据结构提供了丰富的功能和灵活的操作，可以满足各种复杂的应用场景。
> 3. 数据持久化：Redis提供了持久化功能，可以将数据保存到磁盘上，以便在系统重启后仍然保留数据。这种持久化可以通过快照（snapshotting）和日志追加（append-only log）两种方式来实现。这使得Redis不仅可以用作缓存，还可以作为持久化存储解决方案。
> 4. 分布式支持：Redis提供了一些分布式功能，如主从复制（master-slave replication）和集群（cluster），使得它可以在多个节点上进行数据复制和分布式存储。这些功能增加了数据的可靠性、扩展性和负载均衡能力。
> 5. 丰富的功能：Redis提供了许多高级功能，如事务支持、原子操作、发布订阅模式、按范围查询、过期设置和Lua脚本等。这些功能使开发人员可以构建复杂的应用逻辑和解决各种需求。
> 6. 社区支持和生态系统：Redis是一个开源项目，拥有庞大的活跃社区。这意味着开发人员可以从社区中获取支持、学习经验和共享解决方案。此外，Redis还有丰富的客户端库和工具生态系统，支持多种编程语言和开发环境。
>
> 综上所述，Redis具有高性能、多样的数据结构、数据持久化、分布式支持、丰富的功能以及强大的社区支持和生态系统，使其成为一种强大而受欢迎的数据存储解决方案。

**应用场景:**

> 1. 缓存：作为缓存层，Redis可以将常用的数据存储在内存中，以加快读取速度。它可以显著降低后端数据库的负载，提升网站和应用程序的性能。由于Redis具有高速的读写能力和丰富的数据结构，它被广泛应用于高流量网站、电子商务平台和实时数据分析等场景。
> 2. 会话存储：Redis可以用于存储用户会话数据，尤其适用于分布式系统和负载均衡环境。通过将会话数据存储在Redis中，可以实现会话共享和状态管理，并提供可扩展性和高可用性。
> 3. 消息队列：Redis的发布订阅功能和列表数据结构可以用于构建高性能的消息队列系统。它可以作为消息代理，处理实时消息传递和事件驱动的应用程序，例如实时通知、实时聊天、日志收集和任务队列等。
> 4. 地理位置服务：Redis的有序集合数据结构可以用于存储地理位置信息，并通过地理位置索引进行查询。这使得Redis在构建位置服务和附近搜索功能时非常有用，如附近的商家、车辆追踪和地理围栏等应用。
> 5. 实时排行榜：Redis的有序集合可以存储分数和成员之间的关联，并支持按分数范围进行排名和查询。这使得Redis在构建实时排行榜和热门排名功能时非常高效，如实时游戏排名、热门文章和社交媒体趋势等。
> 6. 分布式锁：Redis的原子操作和分布式功能可以用于实现分布式锁。通过Redis的锁机制，可以确保在分布式系统中只有一个进程可以执行关键代码段，从而实现并发控制和资源管理。
> 7. 共享session
>
> 除了以上应用场景，Redis还可以用于缓存预热、数据统计与计数、实时数据分析和推荐系统等多种领域。由于其灵活性和高性能，Redis在许多应用中成为关键的基础设施组件。

**缺点:**

> 1. 内存限制：Redis的数据存储完全依赖于内存，这意味着它的存储容量受到物理内存的限制。如果数据量超过可用内存大小，就需要进行分片或其他策略来处理。此外，由于数据存储在内存中，系统重启后需要重新加载数据，这可能会导致一段时间的不可用。
> 2. 单线程模型：默认情况下，Redis使用单线程模型来处理所有的请求。这意味着它无法充分利用多核处理器的优势。在某些高并发场景下，这可能成为性能瓶颈。尽管Redis通过异步操作和非阻塞IO来提高性能，但在特定情况下，单线程模型可能限制了其吞吐量。
> 3. 持久化延迟：当Redis使用持久化机制将数据写入磁盘时，会引入额外的IO操作，这可能会增加写操作的延迟。快照持久化可能会在重启后需要花费一段时间来加载数据，而日志追加持久化则可能导致写操作的延迟增加。
> 4. 数据一致性：由于Redis默认情况下是以异步方式进行数据持久化的，因此在发生故障时，可能会丢失最后一次持久化之后的数据。这意味着在需要强一致性的场景下，需要额外的配置和操作来确保数据的完整性。
> 5. 有限的查询功能：虽然Redis提供了一些查询功能，如按范围查询和模式匹配，但它并不是设计用于大规模的复杂查询和数据分析。如果应用需要复杂的查询操作，可能需要借助其他数据库系统的支持。
> 6. 数据类型限制：虽然Redis支持多种数据结构，但每种数据结构都有一些限制。例如，字符串值的大小受到一定限制，列表和集合的元素数量也有上限。这些限制可能会对某些应用场景造成影响。

### 2.redis的存储结构有哪些

String： 键值对。应用场景：缓存、短信验证码等。

```shell
set key value  //设置值
get key        //获取值
```

Hash： 键值对，可以存放多个键值对，适合存储对象。应用场景：缓存等，比String更节省空间。

```shell
hset key field value //设置值
hget key field       //获取值
```

List： 相当于链表。应用场景：消息队列等。

```shell
LPUSH key  element1 element2 element3 ...   //左边插入元素，头插法
LPOP key                                    //移除并返回列表左侧的第一个元素，没有则返回nil
```

Set： HashSet类似，无序，不可重复。应用场景：共同好友等。

```shell
SADD key member1 member2 member3 ...  //向set中添加一个或多个元素
SREM key member1   //移除set中的指定元素
```

Zset： 类似TreeSet，不可重复，有一个权重参数，按这个排序。应用场景：排行榜。

```shell
ZADD key score1 member1 score2 member2 score3 member3  //添加一个或多个元素到sorted set ，如果已经存在则更新其score值
ZREM key member1                                       //删除sorted set中的一个指定元素
```

### 3.为什么要用redis和redis为什么那么快

①内存操作，速度快。每秒读11万次，写8万次。
②支持事务和持久化。
③单线程，避免了线程的切换。redis 6 引进了多线程。
④采用IO多路复用，单线程处理多个连接请求。

### 4.缓存雪崩、缓存穿透、缓存击穿

#### 缓存雪崩

> 缓存中的数据大量过期，然后大量请求去访问数据库，导致数据库压力过大或者down机。或者redis宕机了。
> **解决：**
> ①使缓存过期时间分布比较均匀。
> ②设置高可用集群。

#### 缓存穿透

> 缓存和数据库都没有要的数据，然后会一直请求，给数据库压力。
> **解决：**
> ①给缓存设置一个空值或者默认值。
> ②使用布隆过滤器。先通过过滤器判断数据是否存在，存在再继续向下查。

#### 缓存击穿

> 某个key过期，恰巧有大量请求访问这个key，然后导致数据库压力过大。
> **解决：**
> ①使用互斥锁，只让一个请求去访问，然后把数据带到缓存，然后剩余请求再去访问请求。
> ②设置缓存不过期。

### 5.redis的持久机制

#### RDB(默认)

 一定时间内将内存数据以快照(记录某一时刻数据，相当于拍了一张照片)形式保存到硬盘中。某个时间点把数据写到临时文件，然后替换上次持久化的文件。

```shell
# 在10秒之后，如果至少有 1 个 key 发生变化，Redis就会自动创建快照
save 10 1 
```

**优点：** 恢复大的数据集时，比AOF效率更高。
**缺点：** 不安全，数据丢失。

#### AOF

会把每次写的命令记录到日志文件(同一个日志文件，不会替换)，redis重启会将持久化的日志文件恢复。如果两种持久化都开启，优先恢复AOF。

```shell
# 开启 AOF 持久化
appendonly yes  

# 每次有数据修改发生时都会写入 AOF 文件，速度缓慢但是最安全
appendfsync always    

# 每秒钟同步一次，显示地将多个写命令同步到硬盘。AOF 默认使用的
appendfsync everysec  

# 让操作系统决定何时进行同步，速度最快
appendfsync no      
```

**优点：** 安全，几乎不会丢失数据。
**缺点：** AOF文件比RDB文件大，且恢复速度慢。

### 6.redis的过期策略

#### 定时删除

 每个key都需要创建一个定时器，到时间就会清除key，所以对内存很友好，但是会占用cpu的大量资源去处理过期。

#### 惰性删除

 用到key的时候再去判断过没过期，过期就清除，可以节省cpu的资源，但是对内存不友好。可能出现大量过期的key没有清除。

#### 定期删除

定时删除和惰性删除的结合体，每隔一段时间抽取设置过期的key检测是否过期(默认是1s执行10次清除，每次抽取5个检测)，过期就清除。

```shell
# 1秒检查10次
hz 10 

# 一次抽取的个数，默认是5个
maxmemory-samples 5
```

### 7.redis的淘汰策略

redis内存满了，进行内存淘汰，删除一部分key。redis 4.0 添加的lfu策略。

```shell
# 默认的最大内存设置为1GB
maxmemory 1GB
```

①volatile-lru： 针对设置了过期时间的key，使用lru算法(最近最少使用的key：根据时间)进行淘汰。
②allkeys-lru： 针对所有key使用lru算法进行淘汰。
③volatile-lfu： 针对设置了过期时间的key，使用lfu算法(最近最少使用：根据计数器)进行淘汰。
④allkeys-lfu： 针对所有key使用lfu算法进行淘汰。
⑤volatile-random： 从所有设置了过期时间的key中使用随机淘汰机制进行淘汰。
⑥allkeys-random： 针对所有的key使用随机淘汰机制进行淘汰。
⑦volatile-ttl： 删除过期时间最早(剩余存活时间最短的)。
⑧no-eviction(默认)： 不删除键，操作报错。

### 8.redis怎么设置高可用或者集群

①主从复制： 一个主，一个或多个从，从节点在主节点复制数据。主节点负责写，从节点负责读。可以更好的分担主节点的压力，但是如果主节点宕机了，会导致部分数据不同步。
②哨兵模式(重点)： 也是一种主从模式，哨兵定时去查询主机，如果主机太长时间没有相应，多个哨兵就投票选出新的主机。提高了可用性，但是在选举新的主节点期间，还是不能工作。
③Cluster集群模式： 采用多主多从(一般都是三主三从)，按照规则进行分片，每台redis节点储存的数据不一样，解决了单机储存的问题。还提供了复制和故障转移功能。配置比较麻烦。

### 9.redis实现分布式锁

**分布式锁：** 

是控制分布式系统不同进程共同访问共享资源的一种锁的实现。秒杀下单、抢红包等等业务场景，都需要用到分布式锁。redis可以当分布式锁。

**特征:**

> 互斥性: 任意时刻，只有一个客户端能持有锁
> 锁超时释放： 持有锁超时，可以释放，防止不必要的资源浪费，也可以防止死锁
> 可重入性： 一个线程如果获取了锁之后,可以再次对其请求加锁
> 高性能和高可用： 加锁和解锁需要开销尽可能低，同时也要保证高可用，避免分布式锁失效
> 安全性： 锁只能被持有的客户端删除，不能被其他客户端删除

#### 1.命令setnx + expire分开写。

```shell
#新增一个key，key存在返回1，不存在不增加返回0
setnx key value 

#key过100秒过期。单位是秒
expire key 100

# 问题：
# 1.无法保证原子性，setnx锁了之后，然后出现问题，过期时间没有设置，那么锁就是永久的了(别的线程就永远获取不到锁了)。
```

#### 2.setnx + value 值是过期时间。

```shell
setnx key 过期时间 
# 把过期时间放到value，解决过期时间没有设置的问题，对比过期时间和当前时间就可以知道是否过期。
# 问题：
# 1.取当前时间，分布式要求时间同步。
```

#### 3.使用Lua脚本(包含SETNX + EXPIRE两条指令：保证原子性)。

#### 4.set的扩展命令(SET key value[EX seconds][PX milliseconds][NX|XX])。

```shell
# EX seconds:将键的过期时间设置为 seconds 秒。
# PX milliseconds:将键的过期时间设置为 milliseconds 毫秒。
# NX:只在键不存在的时候，才对键进行设置操作。SET key value NX 等同于 SETNX key value
# XX:只在键已经存在的时候，才对键进行设置操作

set key value ex 10 nx
# key不存在才能新增，并且设置过期时间为10s。
# 问题：
# 1.锁过期释放了，业务还没执行完。a获取锁，执行时间超过10秒，然后被b线程获取锁，导致代码执行顺序不一致。
# 2.锁被误删，因为1, a没执行完释放锁，被b获取，然后a执行完，删除锁，然后b可能还没执行完。
```

#### 5.set ex px nx + 校验唯一随机值,再删除。

> 把 value设置成一个随机数，删除的时候对比随机数，一致再删除。	
> 问题：还是存在业务没执行完，锁释放。

#### 6.开源框架Redisson：

给获得锁的线程，开启一个定时守护线程，每隔一段时间检查锁是否还存在，存在则对锁的过期时间延长，防止锁过期提前释放。

#### 7.多机实现的分布式锁Redlock。假设有5个主节点，再五台服务器上运行。

> 按顺序向5个master节点请求加锁
> 根据设置的超时时间来判断，是不是要跳过该master节点。锁过期时间是10ms，超时时间是20ms，那么就跳过。
> 如果大于等于3个节点(N/2+1)加锁成功，并且使用的时间小于锁的有效期，即可认定加锁成功啦。
> 如果获取锁失败，再所有主节点解锁，没获取到锁也会解锁，防止九年义务教育漏网之鱼。